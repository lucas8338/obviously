#' @title vector_crossedUpAndDown
#' @description will identify values which vector has crossed the especific points. the objective
#' of this function os just to save the indexes of values that are crosses, this way i can use
#' data in anothers tranformations. so this fitted function dont need to be saved.
#' @param vec a numeric vector.
#' @param crosses a numeric vector with values which crosses will be used
#' @param crosses.names a list with vectors, each index of the list is a character vector with
#' the first position is the name to be applied to values which are coming from bellow to above the
#' crosses value.
#' # which crosses from bellow to above are the first, above to bellow are the second.
#' example: list( c('crossUp20','crossDn20'), c('crossUp80','crossDn80') )
#' NA values mean to be generated by the function.
#' @param tPlusX is the lag to identify crosses.
#' @return a list to be passed to the predict method.
#' @import dplyr
#' @export
vector_crossedUpAndDown<- function(vec, crosses, crosses.names=rep(NA,length(crosses)), tPlusX=1){
  stopifnot("'vec' cant be different from numeric"=is.numeric(vec))

  data<- vec
  data.copy<- vec

  result<- list(data=data)

  # create a data.frame with the data and a lagged version to use vector operation.
  times<- data.frame('present'=data, 'past'=dplyr::lag(data, n=tPlusX))

  for ( i in 1:(length(crosses)) ){
    crossValue<- crosses[[i]]
    crossValue.char<- crossValue %>% as.character()
    crossValue.names<- crosses.names[[i]]
    # bellow will generate names if not set.
    if ( all(is.na(crossValue.names)) ){
      crossValue.names[[1]]<- glue::glue("crossDnToUp{crossValue}")
      crossValue.names[[2]]<- glue::glue("crossUpToDn{crossValue}")
    }
    stopifnot(length(crossValue.names)==2)
    # takes which indexes the cross from down to up happened
    crossedUp<- which(times[,'present'] >= crossValue & times[,'past'] < crossValue)
    # takes which index occurred up to down
    crossedDn<- which(times[,'present'] <= crossValue & times[,'past'] > crossValue)
    # create a index in the result for this cross value and will sorate data to predict.
    result[[crossValue.char]]<- list()
    result[[crossValue.char]][['crossedUp']]<- crossedUp
    result[[crossValue.char]][['crossedDn']]<- crossedDn
    result[[crossValue.char]][['names']]<- crossValue.names
  }

  class(result)<- 'vector_crossedUpAndDown'

  result
}